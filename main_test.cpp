
// This program *** calculates *** A(p^2) and B(p^2) from the DSE (iterative Eqs.) and then uses it
// to calculate the mass, which is B(p^2)/A(p^2).


#include <iostream>
#include <cmath>
#include <fstream>
#include <string>
#include "definitions.h"
#include "help_numerics.h"
#include "Dyson_test.h"
#include "progressbar.hpp"
#include "lookuptable.h"
#include <complex>
#include <stdio.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_eigen.h>




int main(){
  std::cout.precision(17); // ##### set precision to 17 values after comma ######

  // ##### Constants ###### //
 // std::ofstream gmorpionmass;
 // gmorpionmass.open("Data/gmorpionmass.dat");
 // gmorpionmass<<"#Stromquarkmass and Pionmass"<<std::endl;
 // for(int i=0; i<10;i++){
  double m_g=0.132;
  double epsilon=1e-10;
  double m_c = 0.0037;
  double eta = 1.8;
  double g_squared = 1.0;


  // ##### Weights and abscissas are generated by the gauleg function in help_numerics.h. gauleg then returns a 2d array, which is split below. #####
  // ##### The gauleg function is called twice, thought, because of angular integration *and* momentum integration. #####

  double** x_and_w = nullptr;
  double** BSE_x_and_w = nullptr;
  double** x_and_w_ang = nullptr;
  double** BSE_x_and_w_ang = nullptr;
  double** x_and_w_ang_2 = nullptr;
  double* weights_w = nullptr;
  double* BSE_weights_w = nullptr;
  double* absciss_x = nullptr;
  double* BSE_absciss_x = nullptr;
  double* absciss_ang = nullptr;
  double* BSE_absciss_ang = nullptr;
  double* weights_ang = nullptr;
  double* BSE_weights_ang = nullptr;
  double* absciss_ang_2 = nullptr;
  double* weights_ang_2 = nullptr;

  double** vals = nullptr;

  std::complex<double> imag = {0.0,1.0};

  #ifdef MarisTandy
    std::cout<<std::endl<< "Using Maris Tandy Model ";
  #else
    std::cout<<std::endl<< "Now Using Contact Model!";
  #endif

  // ##### Creating abscissas and weights. Using a Log-grid. #####
  #ifdef loggrid

  std::cout<< " with Log-Grid!"<< std::endl;
  x_and_w = gauleg(log(LAMBDA_MIN*LAMBDA_MIN),log(LAMBDA), absciss_points);
  BSE_x_and_w = gauleg(log(LAMBDA_MIN*LAMBDA_MIN),log(LAMBDA), BSE_absciss_points);


  #else

  std::cout<< " Linear-Grid!" << std::endl << std::endl;
  x_and_w = gauleg(0.0,LAMBDA, absciss_points);

  #endif

  // ##### Splitting 2d array up (momentum) #####
  absciss_x = x_and_w[0]; // x_and_w[0];
  weights_w = x_and_w[1]; // x_and_w[1];
  BSE_absciss_x = BSE_x_and_w[0]; // x_and_w[0];
  BSE_weights_w = BSE_x_and_w[1]; // x_and_w[1];


  x_and_w_ang = gauleg(0.0,M_PI, ang_absciss_points);
  BSE_x_and_w_ang = gauleg(0.0,M_PI, BSE_ang_absciss_points);


  x_and_w_ang_2 = gauleg(0.0,M_PI, ang_absciss_points_2); // For second angular integral in BSE. (theta)

  // ##### Splitting 2d array up (angular) #####

  absciss_ang = x_and_w_ang[0];
  weights_ang = x_and_w_ang[1];

  BSE_absciss_ang = BSE_x_and_w_ang[0];
  BSE_weights_ang = BSE_x_and_w_ang[1];

  absciss_ang_2 = x_and_w_ang_2[0];
  weights_ang_2 = x_and_w_ang_2[1];

  // ##### Save A and B to array "vals" #####
  vals = iterate_dressing_functions(epsilon,m_c,m_g,absciss_x,weights_w,absciss_ang,weights_ang, g_squared, eta, mu_renorm);

  // ##### Preparing for mass function M(p^2) = B(p^2)/A(p^2). #####
  double* a_vals = vals[0];
  double* b_vals = vals[1];
  double* renorm_constants = vals[2];
  double* m_vals = nullptr;
  m_vals = new double[absciss_points];
  // std::cout<<" here ok " << std::endl;

  for(int i = 0; i < absciss_points; i++){
    if(a_vals[i] == 0.0){
      m_vals[i] = 0.0;
    }
    else{
      m_vals[i] = b_vals[i]/a_vals[i];
    }
  }

  std::complex<double>* renormpointabvals = interpolation_cmplx(mu_renorm, m_c, renorm_constants, a_vals, b_vals, absciss_x, absciss_ang, weights_w,weights_ang, eta);

  std::cout<<"A(mu) = " << renormpointabvals[0] << " B(mu) = " << renormpointabvals[1] << " M(mu) = "<< renormpointabvals[2] <<std::endl;

  std::cout<<"Z2 is: "<<  renorm_constants[0] << " Zm is: " << renorm_constants[1] << std::endl;

  std::cout<<"PionMass-Input is: "<<  PionMass << " Alpha-Angle is : " << alpha_angle << std::endl;

    #ifdef iterate_quark
      precalculation(m_c, renorm_constants, a_vals, b_vals, absciss_x,absciss_ang,weights_w,weights_ang,eta);
    #endif




  double* q_vec = nullptr;
  double* z_vec = nullptr;
  double* x_corners = nullptr;
  std::complex<double>* a_corners = nullptr;
  std::complex<double>* b_corners = nullptr;

  q_vec = new double[absciss_points];
  z_vec = new double[ang_absciss_points];
  x_corners = new double[4];
  a_corners = new std::complex<double>[4];
  b_corners = new std::complex<double>[4];


  std::complex<double>*** y_corner = nullptr;
  y_corner = new std::complex<double>** [2];
  y_corner[0] = nullptr;
  y_corner[1] = nullptr;
  y_corner[0] = new std::complex<double>*[absciss_points];
  y_corner[1] = new std::complex<double>*[absciss_points];
  for(int i=0;i<absciss_points;i++){
    y_corner[0][i] = nullptr;
    y_corner[0][i] = new std::complex<double>[ang_absciss_points];
    y_corner[1][i] = nullptr;
    y_corner[1][i] = new std::complex<double>[ang_absciss_points];
  }

  double routing_plus = 0.5;

  read_in_data("Data/DressingFunctionsABCmplxInterpol_even_rougherPI_MAX.dat",q_vec,z_vec,y_corner);

  double status = 0.0;

  std::complex<double>***** theta_matrix = initialize_theta_matrix(renorm_constants, BSE_absciss_x, BSE_absciss_ang, BSE_weights_w, BSE_weights_ang, eta, alpha_angle);

  status = regulaFalsi(0.125,0.145,1e-5, a_corners, b_corners, BSE_weights_ang,BSE_absciss_x,BSE_absciss_ang, theta_matrix, q_vec, z_vec, x_corners, y_corner);

  std::cout<< "Pion Mass (iterated) is: " << status << std::endl;
  return 0;
}
